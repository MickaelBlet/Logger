// Generated by amalgamate.py
#ifndef _AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_LOGGER_H_
#define _AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_LOGGER_H_

// ---------------------------
// Start include/blet/logger.h
// ---------------------------
/**
 * logger.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2023 BLET MickaÃ«l.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef _BLET_LOGGER_H_
#define _BLET_LOGGER_H_

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <time.h>

#include <exception>
#include <map>
#include <sstream>
#include <string>

// #include "blet/logger/default.h"
// -----------------------------------
// Start include/blet/logger/default.h
// -----------------------------------

#ifndef _BLET_LOGGER_DEFAULT_H_
#define _BLET_LOGGER_DEFAULT_H_

#ifndef LOGGER_DEFAULT_FILTER_LEVEL
#define LOGGER_DEFAULT_FILTER_LEVEL \
    ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7))
#endif

#ifndef LOGGER_DEFAULT_DROP_FILTER_LEVEL
#define LOGGER_DEFAULT_DROP_FILTER_LEVEL ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6))
#endif

#ifndef LOGGER_DEFAULT_QUEUE_SIZE
#define LOGGER_DEFAULT_QUEUE_SIZE 17
#endif

#ifndef LOGGER_DEFAULT_MESSAGE_MAX_SIZE
#define LOGGER_DEFAULT_MESSAGE_MAX_SIZE 2048
#endif

#ifndef LOGGER_DEFAULT_FORMAT
#define LOGGER_DEFAULT_FORMAT \
    "{level:%-6s} [{pid}:{tid}] {name:%10s}: {time}.{decimal:%03d}:{file: %25s:}{line:%-3d} {message}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_EMERGENCY
#define LOGGER_DEFAULT_FORMAT_COLOR_EMERGENCY "{bg_magenta}{fg_black}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_ALERT
#define LOGGER_DEFAULT_FORMAT_COLOR_ALERT "{fg_magenta}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_CRITICAL
#define LOGGER_DEFAULT_FORMAT_COLOR_CRITICAL "{bg_red}{fg_black}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_ERROR
#define LOGGER_DEFAULT_FORMAT_COLOR_ERROR "{fg_red}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_WARNING
#define LOGGER_DEFAULT_FORMAT_COLOR_WARNING "{fg_yellow}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_NOTICE
#define LOGGER_DEFAULT_FORMAT_COLOR_NOTICE "{fg_blue}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_INFO
#define LOGGER_DEFAULT_FORMAT_COLOR_INFO "{fg_cyan}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#ifndef LOGGER_DEFAULT_FORMAT_COLOR_DEBUG
#define LOGGER_DEFAULT_FORMAT_COLOR_DEBUG "{fg_green}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

#endif // #ifndef _BLET_LOGGER_DEFAULT_H_

// ---------------------------------
// End include/blet/logger/default.h
// ---------------------------------

// #include "blet/logger/macro.h"
// ---------------------------------
// Start include/blet/logger/macro.h
// ---------------------------------

#ifndef _BLET_LOGGER_MACRO_H_
#define _BLET_LOGGER_MACRO_H_

#if defined _WIN32 || defined _WIN64 || defined __CYGWIN__
#define _LOGGER_SEPARATOR_PATH '\\'
#else
#define _LOGGER_SEPARATOR_PATH '/'
#endif

#if defined _WIN32 || defined _WIN64
#define _LOGGER_FUNCTION_NAME __FUNCTION__
#else
#define _LOGGER_FUNCTION_NAME __func__
#endif

#define _LOGGER_FILE_INFOS __FILE__, (::strrchr(__FILE__, _LOGGER_SEPARATOR_PATH) + 1), __LINE__, _LOGGER_FUNCTION_NAME

/**
 * @brief Get the main logger
 */
#define LOGGER_MAIN() ::blet::Logger::getMain()

/**
 * @brief Add logger with a id
 */
#define LOGGER_REGISTER_WITH_ID(logger, id) ::blet::LoggerManager<id>::set(logger)
/**
 * @brief Get logger from id
 */
#define LOGGER_FROM_ID(id) ::blet::LoggerManager<id>::get()

#ifdef LOGGER_VARIADIC_MACRO

#define _LOGGER_LOG_FMT(logger, level, ...)                \
    do {                                                   \
        if (logger._M_lock(level)) {                       \
            logger._M_logFormat(##__VA_ARGS__);            \
            logger._M_logInfos(level, _LOGGER_FILE_INFOS); \
            logger._M_unlock();                            \
        }                                                  \
    } while (0)

/**
 * @brief Emergency log to main logger
 */
#define LOGGER_EMERG_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::EMERGENCY_LEVEL, __VA_ARGS__)
/**
 * @brief Alert log to main logger
 */
#define LOGGER_ALERT_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::ALERT_LEVEL, __VA_ARGS__)
/**
 * @brief Critical log to main logger
 */
#define LOGGER_CRIT_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::CRITICAL_LEVEL, __VA_ARGS__)
/**
 * @brief Error log to main logger
 */
#define LOGGER_ERROR_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::ERROR_LEVEL, __VA_ARGS__)
/**
 * @brief Warning log to main logger
 */
#define LOGGER_WARN_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::WARNING_LEVEL, __VA_ARGS__)
/**
 * @brief Notice log to main logger
 */
#define LOGGER_NOTICE_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::NOTICE_LEVEL, __VA_ARGS__)
/**
 * @brief Info log to main logger
 */
#define LOGGER_INFO_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::INFO_LEVEL, __VA_ARGS__)
/**
 * @brief Debug log to main logger
 */
#define LOGGER_DEBUG_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), ::blet::Logger::DEBUG_LEVEL, __VA_ARGS__)

/**
 * @brief Emergency log to logger id
 */
#define LOGGER_ID_EMERG_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id::), blet::Logger::EMERGENCY, __VA_ARGS__)
/**
 * @brief Alert log to logger id
 */
#define LOGGER_ID_ALERT_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id), ::blet::Logger::ALERT_LEVEL, __VA_ARGS__)
/**
 * @brief Critical log to logger id
 */
#define LOGGER_ID_CRIT_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id), ::blet::Logger::CRITICAL_LEVEL, __VA_ARGS__)
/**
 * @brief Error log to logger id
 */
#define LOGGER_ID_ERROR_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id), ::blet::Logger::ERROR_LEVEL, __VA_ARGS__)
/**
 * @brief Warning log to logger id
 */
#define LOGGER_ID_WARN_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id), ::blet::Logger::WARNING_LEVEL, __VA_ARGS__)
/**
 * @brief Notice log to logger id
 */
#define LOGGER_ID_NOTICE_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id), ::blet::Logger::NOTICE_LEVEL, __VA_ARGS__)
/**
 * @brief Info log to logger id
 */
#define LOGGER_ID_INFO_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id), ::blet::Logger::INFO_LEVEL, __VA_ARGS__)
/**
 * @brief Debug log to logger id
 */
#define LOGGER_ID_DEBUG_FMT(id, ...) _LOGGER_LOG_FMT(LOGGER_FROM_ID(id), ::blet::Logger::DEBUG_LEVEL, __VA_ARGS__)

/**
 * @brief Emergency log to logger
 */
#define LOGGER_TO_EMERG_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::EMERGENCY_LEVEL, __VA_ARGS__)
/**
 * @brief Alert log to logger
 */
#define LOGGER_TO_ALERT_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::ALERT_LEVEL, __VA_ARGS__)
/**
 * @brief Critical log to logger
 */
#define LOGGER_TO_CRIT_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::CRITICAL_LEVEL, __VA_ARGS__)
/**
 * @brief Error log to logger
 */
#define LOGGER_TO_ERROR_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::ERROR_LEVEL, __VA_ARGS__)
/**
 * @brief Warning log to logger
 */
#define LOGGER_TO_WARN_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::WARNING_LEVEL, __VA_ARGS__)
/**
 * @brief Notice log to logger
 */
#define LOGGER_TO_NOTICE_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::NOTICE_LEVEL, __VA_ARGS__)
/**
 * @brief Info log to logger
 */
#define LOGGER_TO_INFO_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::INFO_LEVEL, __VA_ARGS__)
/**
 * @brief Debug log to logger
 */
#define LOGGER_TO_DEBUG_FMT(logger, ...) _LOGGER_LOG_FMT(logger, ::blet::Logger::DEBUG_LEVEL, __VA_ARGS__)

#endif

/**
 * @brief Use format method for get the custom message
 */
#define _LOGGER_LOG_FMT_P(logger, level, parenthesis_msg)  \
    do {                                                   \
        if (logger._M_lock(level)) {                       \
            logger._M_logFormat parenthesis_msg;           \
            logger._M_logInfos(level, _LOGGER_FILE_INFOS); \
            logger._M_unlock();                            \
        }                                                  \
    } while (0)

/**
 * @brief Emergency log to main logger
 */
#define LOGGER_EMERG_FMT_P(parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::EMERGENCY_LEVEL, parenthesis_msg)
/**
 * @brief Alert log to main logger
 */
#define LOGGER_ALERT_FMT_P(parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::ALERT_LEVEL, parenthesis_msg)
/**
 * @brief Critical log to main logger
 */
#define LOGGER_CRIT_FMT_P(parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::CRITICAL_LEVEL, parenthesis_msg)
/**
 * @brief Error log to main logger
 */
#define LOGGER_ERROR_FMT_P(parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::ERROR_LEVEL, parenthesis_msg)
/**
 * @brief Warning log to main logger
 */
#define LOGGER_WARN_FMT_P(parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::WARNING_LEVEL, parenthesis_msg)
/**
 * @brief Notice log to main logger
 */
#define LOGGER_NOTICE_FMT_P(parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::NOTICE_LEVEL, parenthesis_msg)
/**
 * @brief Info log to main logger
 */
#define LOGGER_INFO_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::INFO_LEVEL, parenthesis_msg)
/**
 * @brief Debug log to main logger
 */
#define LOGGER_DEBUG_FMT_P(parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::DEBUG_LEVEL, parenthesis_msg)

/**
 * @brief Emergency log to logger id
 */
#define LOGGER_ID_EMERG_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::EMERGENCY_LEVEL, parenthesis_msg)
/**
 * @brief Alert log to logger id
 */
#define LOGGER_ID_ALERT_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::ALERT_LEVEL, parenthesis_msg)
/**
 * @brief Critical log to logger id
 */
#define LOGGER_ID_CRIT_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::CRITICAL_LEVEL, parenthesis_msg)
/**
 * @brief Error log to logger id
 */
#define LOGGER_ID_ERROR_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::ERROR_LEVEL, parenthesis_msg)
/**
 * @brief Warning log to logger id
 */
#define LOGGER_ID_WARN_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::WARNING_LEVEL, parenthesis_msg)
/**
 * @brief Notice log to logger id
 */
#define LOGGER_ID_NOTICE_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::NOTICE_LEVEL, parenthesis_msg)
/**
 * @brief Info log to logger id
 */
#define LOGGER_ID_INFO_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::INFO_LEVEL, parenthesis_msg)
/**
 * @brief Debug log to logger id
 */
#define LOGGER_ID_DEBUG_FMT_P(id, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(LOGGER_FROM_ID(id), ::blet::Logger::DEBUG_LEVEL, parenthesis_msg)

/**
 * @brief Emergency log to logger
 */
#define LOGGER_TO_EMERG_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::EMERGENCY_LEVEL, parenthesis_msg)
/**
 * @brief Alert log to logger
 */
#define LOGGER_TO_ALERT_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::ALERT_LEVEL, parenthesis_msg)
/**
 * @brief Critical log to logger
 */
#define LOGGER_TO_CRIT_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::CRITICAL_LEVEL, parenthesis_msg)
/**
 * @brief Error log to logger
 */
#define LOGGER_TO_ERROR_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::ERROR_LEVEL, parenthesis_msg)
/**
 * @brief Warning log to logger
 */
#define LOGGER_TO_WARN_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::WARNING_LEVEL, parenthesis_msg)
/**
 * @brief Notice log to logger
 */
#define LOGGER_TO_NOTICE_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::NOTICE_LEVEL, parenthesis_msg)
/**
 * @brief Info log to logger
 */
#define LOGGER_TO_INFO_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::INFO_LEVEL, parenthesis_msg)
/**
 * @brief Debug log to logger
 */
#define LOGGER_TO_DEBUG_FMT_P(logger, parenthesis_msg) \
    _LOGGER_LOG_FMT_P(logger, ::blet::Logger::DEBUG_LEVEL, parenthesis_msg)

/**
 * @brief Use format method for get the custom message
 */
#define _LOGGER_LOG(logger, level, stream)                 \
    do {                                                   \
        if (logger._M_lock(level)) {                       \
            ::std::ostringstream __loggerTmpOss("");       \
            __loggerTmpOss << stream;                      \
            logger._M_logStream(__loggerTmpOss);           \
            logger._M_logInfos(level, _LOGGER_FILE_INFOS); \
            logger._M_unlock();                            \
        }                                                  \
    } while (0)

#define LOGGER_EMERG(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::EMERGENCY_LEVEL, stream)
#define LOGGER_ALERT(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::ALERT_LEVEL, stream)
#define LOGGER_CRIT(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::CRITICAL_LEVEL, stream)
#define LOGGER_ERROR(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::ERROR_LEVEL, stream)
#define LOGGER_WARN(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::WARNING_LEVEL, stream)
#define LOGGER_NOTICE(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::NOTICE_LEVEL, stream)
#define LOGGER_INFO(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::INFO_LEVEL, stream)
#define LOGGER_DEBUG(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::DEBUG_LEVEL, stream)

#define LOGGER_TO_EMERG(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::EMERGENCY_LEVEL, stream)
#define LOGGER_TO_ALERT(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::ALERT_LEVEL, stream)
#define LOGGER_TO_CRIT(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::CRITICAL_LEVEL, stream)
#define LOGGER_TO_ERROR(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::ERROR_LEVEL, stream)
#define LOGGER_TO_WARN(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::WARNING_LEVEL, stream)
#define LOGGER_TO_NOTICE(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::NOTICE_LEVEL, stream)
#define LOGGER_TO_INFO(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::INFO_LEVEL, stream)
#define LOGGER_TO_DEBUG(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::DEBUG_LEVEL, stream)

#define LOGGER_FLUSH() LOGGER_MAIN().flush()
#define LOGGER_ID_FLUSH(id) LOGGER_FROM_ID(id).flush()
#define LOGGER_TO_FLUSH(logger) logger.flush()

#define LOGGER_APPLICATE_DEFAULT_COLOR()                                                                  \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::EMERGENCY_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_EMERGENCY); \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::ALERT_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_ALERT);         \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::CRITICAL_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_CRITICAL);   \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::ERROR_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_ERROR);         \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::WARNING_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_WARNING);     \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::NOTICE_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_NOTICE);       \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::INFO_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_INFO);           \
    LOGGER_MAIN().setLevelFormat(::blet::Logger::DEBUG_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_DEBUG)

#define LOGGER_ID_APPLICATE_DEFAULT_COLOR(id)                                                                  \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::EMERGENCY_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_EMERGENCY); \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::ALERT_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_ALERT);         \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::CRITICAL_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_CRITICAL);   \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::ERROR_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_ERROR);         \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::WARNING_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_WARNING);     \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::NOTICE_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_NOTICE);       \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::INFO_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_INFO);           \
    LOGGER_FROM_ID(id).setLevelFormat(::blet::Logger::DEBUG_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_DEBUG)

#define LOGGER_TO_APPLICATE_DEFAULT_COLOR(logger)                                                  \
    logger.setLevelFormat(::blet::Logger::EMERGENCY_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_EMERGENCY); \
    logger.setLevelFormat(::blet::Logger::ALERT_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_ALERT);         \
    logger.setLevelFormat(::blet::Logger::CRITICAL_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_CRITICAL);   \
    logger.setLevelFormat(::blet::Logger::ERROR_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_ERROR);         \
    logger.setLevelFormat(::blet::Logger::WARNING_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_WARNING);     \
    logger.setLevelFormat(::blet::Logger::NOTICE_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_NOTICE);       \
    logger.setLevelFormat(::blet::Logger::INFO_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_INFO);           \
    logger.setLevelFormat(::blet::Logger::DEBUG_LEVEL, LOGGER_DEFAULT_FORMAT_COLOR_DEBUG)

#endif // #ifndef _BLET_LOGGER_MACRO_H_

// -------------------------------
// End include/blet/logger/macro.h
// -------------------------------

// #include "blet/logger/format.h"
// ----------------------------------
// Start include/blet/logger/format.h
// ----------------------------------

/**
 * logger/format.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2023 BLET MickaÃ«l.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef _BLET_LOGGER_FORMAT_H_
#define _BLET_LOGGER_FORMAT_H_

#include <pthread.h>

#include <list>
#include <string>

namespace blet {

namespace logger {

struct Format {
    enum EAction {
        PRINT_ACTION = 0,
        NAME_ACTION = 1,
        LEVEL_ACTION = 2,
        PATH_ACTION = 3,
        FILE_ACTION = 4,
        LINE_ACTION = 5,
        FUNC_ACTION = 6,
        PID_ACTION = 7,
        TID_ACTION = 8,
        TIME_ACTION = 9,
        DECIMAL_ACTION = 10,
        MESSAGE_ACTION = 11
    };

    struct Action {
        inline Action(EAction action_, const std::string& format_) :
            format(format_),
            action(action_) {}
        std::string format;
        EAction action;
    };

    Format();
    Format(const std::string& loggerName, const char* format);
    ~Format();

    std::string originFormat;
    std::list<Action> actions;
    std::string time;
    pthread_t threadId;
    pid_t pid;
    int nsecDivisor;
};

} // namespace logger

} // namespace blet

#endif // #ifndef _BLET_LOGGER_FORMAT_H_

// --------------------------------
// End include/blet/logger/format.h
// --------------------------------

// #include "blet/logger/manager.h"
// -----------------------------------
// Start include/blet/logger/manager.h
// -----------------------------------

#ifndef _BLET_LOGGER_LOGGERMANAGER_H_
#define _BLET_LOGGER_LOGGERMANAGER_H_

#include <pthread.h>

#include <vector>

namespace blet {

class Logger;

template<int ID>
class LoggerManager {
  public:
    static inline void set(Logger& logger) {
        _logger = &logger;
    }
    static inline Logger& get() {
        return *_logger;
    }

  private:
    static Logger* _logger;
};

template<int ID>
Logger* LoggerManager<ID>::_logger = NULL;

} // namespace blet

#endif // #ifndef _BLET_LOGGER_LOGGERMANAGER_H_

// ---------------------------------
// End include/blet/logger/manager.h
// ---------------------------------

// -----------------------------
// Content include/blet/logger.h
// -----------------------------

#ifndef __GNUC__
#ifndef __attribute__
#define __attribute__(X) /* do nothing */
#endif
#endif

// #define LOGGER_ASYNC_WAIT_PRINT

#define LOGGER_LEVEL_NB (::blet::Logger::DEBUG_LEVEL + 1)

namespace blet {

class Logger {
  public:
    class Exception : public std::exception {
      public:
        inline Exception(const char* s1, const char* s2 = "", const char* s3 = "", const char* s4 = "",
                         const char* s5 = "", const char* s6 = "", const char* s7 = "", const char* s8 = "",
                         const char* s9 = "") {
            _str = s1;
            _str += s2;
            _str += s3;
            _str += s4;
            _str += s5;
            _str += s6;
            _str += s7;
            _str += s8;
            _str += s9;
        }
        inline virtual ~Exception() throw() {}
        inline const char* what() const throw() {
            return _str.c_str();
        }

      protected:
        std::string _str;
    };

    enum ELevel {
        EMERGENCY_LEVEL = LOG_EMERG,
        ALERT_LEVEL = LOG_ALERT,
        CRITICAL_LEVEL = LOG_CRIT,
        ERROR_LEVEL = LOG_ERR,
        WARNING_LEVEL = LOG_WARNING,
        NOTICE_LEVEL = LOG_NOTICE,
        INFO_LEVEL = LOG_INFO,
        DEBUG_LEVEL = LOG_DEBUG
    };

    struct Message {
        char* message;
        const char* file;
        const char* filename;
        const char* function;
        struct timespec ts;
        pthread_t tid;
        int line;
        pid_t pid;
        ELevel level;
    };

    typedef void (*printfunction_t)(void* userData, const std::string& name, const Message& message);

    Logger(const char* name);
    ~Logger();

    static inline Logger& getMain() {
        static Logger logger("main");
        return logger;
    }

    inline bool _M_lock(const ELevel& level) {
        bool ret = true;
        if ((1 << level) & _levelFilter) {
            if ((1 << level) & _levelDropFilter) {
                ::pthread_mutex_lock(&_logMutex);
                ::pthread_mutex_lock(&_queueMutex);
                if (_currentMessageId > _queueMaxSize - 1) {
                    ::pthread_cond_wait(&_condLog, &_queueMutex);
                }
            }
            else {
                // without lock
                if (_currentMessageId > _queueMaxSize - 1) {
                    ret = false;
                    ++_dropMessageCounter[::pthread_self() %
                                          (sizeof(_dropMessageCounter) / sizeof(*_dropMessageCounter))];
                }
                else {
                    ::pthread_mutex_lock(&_logMutex);
                    ::pthread_mutex_lock(&_queueMutex);
                    // with lock
                    if (_currentMessageId > _queueMaxSize - 1) {
                        ::pthread_mutex_unlock(&_queueMutex);
                        ::pthread_mutex_unlock(&_logMutex);
                        ++_dropMessageCounter[::pthread_self() %
                                              (sizeof(_dropMessageCounter) / sizeof(*_dropMessageCounter))];
                        ret = false;
                    }
                }
            }
        }
        else {
            ret = false;
        }
        return ret;
    }

    inline void _M_unlock() {
        // move index
        ++_currentMessageId;
        ::pthread_mutex_unlock(&_queueMutex);
        ::pthread_mutex_unlock(&_logMutex);
    }

    inline void increaseByThread() {}

    inline void enableLevel(const ELevel& level) {
        _levelFilter |= (1 << level);
    }
    inline void disableLevel(const ELevel& level) {
        _levelFilter &= ~(1 << level);
    }

    inline void enableDropLevel(const ELevel& level) {
        _levelDropFilter &= ~(1 << level);
    }
    inline void disableDropLevel(const ELevel& level) {
        _levelDropFilter |= (1 << level);
    }

    /**
     * @brief wait the last message and flush FILE
     */
    void flush();

    /**
     * @brief Set format of level
     *
     * @param level
     * @param format
     */
    void setLevelFormat(const ELevel& level, const char* format);

    /**
     * @brief Set all format type.
     * keywords:
     * - name: name of logger
     * - level: level of log
     * - path: __FILE__ of log
     * - file: filename of log
     * - line: __LINE__ of log
     * - func: __func__ of log
     * - pid: process id
     * - time: datetime of log
     * - message: format message of log
     * - microsec: micro seconds
     * - millisec: milli seconds
     * - nanosec: nano seconds
     *
     * @param format C string of format.
     */
    void setAllFormat(const char* format);

    void applicateLevelColor(const ELevel& level, const char* color);

    void applicateAllLevelColor();

    void setFILE(FILE* file);

    void setSyslog(bool active);

    void setUserPrintFunction(printfunction_t printFunction, void* userData);

    __attribute__((__format__(__printf__, 3, 4))) void logSync(ELevel level, const char* format, ...);
    void vlog(ELevel level, const char* format, va_list& vargs);
    __attribute__((__format__(__printf__, 3, 4))) void log(ELevel level, const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void emergency(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void alert(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void critical(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void error(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void warning(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void notice(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void info(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void debug(const char* format, ...);

    /**
     * @brief It's follow by _M_logInfos
     */
    __attribute__((__format__(__printf__, 2, 3))) void _M_logFormat(const char* format, ...);

    /**
     * @brief It's follow by _M_logInfos
     */
    void _M_logStream(const ::std::ostringstream& os);

    /**
     * @brief It's prev by _M_logFormat or _M_logStream
     *
     * @param level
     * @param file
     * @param filename
     * @param line
     * @param function
     */
    void _M_logInfos(ELevel level, const char* file, const char* filename, int line, const char* function);

    const std::string name;

  private:
    typedef void (Logger::*printMethods_t)(const Message& message);

    inline Logger(const Logger&){}; // disable copy
    inline Logger& operator=(const Logger&) {
        return *this;
    }; // disable copy

    struct DebugPerf {
        inline DebugPerf(const char* name_) :
            name(name_),
            messageCount(0),
            messagePrinted(0) {
            clock_gettime(CLOCK_MONOTONIC, &startTime);
        }
        inline ~DebugPerf() {
            ::timespec endTs;
            clock_gettime(CLOCK_MONOTONIC, &endTs);
            if ((endTs.tv_nsec - startTime.tv_nsec) < 0) {
                endTs.tv_nsec = 1000000000 + (endTs.tv_nsec - startTime.tv_nsec);
                endTs.tv_sec -= 1;
            }
            else {
                endTs.tv_nsec = endTs.tv_nsec - startTime.tv_nsec;
            }
            fprintf(stderr, "LOGGER_PERF %s:\n", name.c_str());
            fprintf(stderr, "- Time: %ld.%09ld\n", (endTs.tv_sec - startTime.tv_sec), endTs.tv_nsec);
            fprintf(stderr, "- Message counted: %u\n", messageCount);
            fprintf(stderr, "- Message printed: %u\n", messagePrinted);
            fprintf(stderr, "- Message lost: %u\n", messageCount - messagePrinted);
            fprintf(stderr, "- Message rate: %f\n",
                    messagePrinted / ((endTs.tv_sec - startTime.tv_sec) * 1000000000.0 + endTs.tv_nsec) * 1000000000);
            fflush(stderr);
        }
        std::string name;
        ::timespec startTime;
        unsigned int messageCount;
        unsigned int messagePrinted;
    };

    // thread
    static void* _threadLogger(void* e);
    void _threadLog();

    // print methods
    void _printFILE(const Message& message);
    void _printFILEUser(const Message& message);
    void _printFILESyslog(const Message& message);
    void _printFILEUserSyslog(const Message& message);
    void _printUser(const Message& message);
    void _printUserSyslog(const Message& message);
    void _printSyslog(const Message& message);
    void _choosePrintMethod();
    void _printMessage(const Message& message);

    bool _isStarted;
    bool _toSyslog;
    unsigned int _currentMessageId;
    pthread_mutex_t _queueMutex;
    pthread_mutex_t _logMutex;
    pthread_mutex_t _printMutex;
    pthread_cond_t _condLog;
    pthread_cond_t _condFlush;
    sem_t _queueSemaphore;
    pthread_t _threadLogId;
    int _levelFilter;
    int _levelDropFilter;
    int _dropMessageCounter[101];

    FILE* _pfile;

    unsigned int _messageMaxSize;
    unsigned int _queueMaxSize;
    char* _bufferMessages;
    Message* _messages;
    Message* _messagesSwap;
    printMethods_t _printMethods;

    logger::Format _formats[LOGGER_LEVEL_NB];

    // user print function
    void* _userData;
    printfunction_t _userPrintFunction;

    DebugPerf* _perf;
};

} // namespace blet

#undef LOGGER_LEVEL_NB

#endif // #ifndef _BLET_LOGGER_H_

// -------------------------
// End include/blet/logger.h
// -------------------------

// --------------------
// Start src/logger.cpp
// --------------------
/**
 * logger.cpp
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2023 BLET MickaÃ«l.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// #include "blet/logger.h" (already included)

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

#include <iostream>
#include <list>
#include <map>
#include <string>
#include <vector>

namespace blet {

inline Logger::Logger(const char* name_) :
    name(name_),
    _isStarted(true),
    _toSyslog(false),
    _currentMessageId(0),
    _levelFilter(LOGGER_DEFAULT_FILTER_LEVEL),
    _levelDropFilter(LOGGER_DEFAULT_DROP_FILTER_LEVEL),
    _pfile(stdout),
    _printMethods(&Logger::_printFILE),
    _userData(NULL),
    _userPrintFunction(NULL),
    _perf(
#ifdef LOGGER_PERF_DEBUG
        new DebugPerf(name_)
#else
        NULL
#endif
    ) {
    _messageMaxSize = LOGGER_DEFAULT_MESSAGE_MAX_SIZE;
    _queueMaxSize = LOGGER_DEFAULT_QUEUE_SIZE;
    if (_queueMaxSize == 0) {
        _queueMaxSize = 1;
    }
    _bufferMessages = new char[_queueMaxSize * LOGGER_DEFAULT_MESSAGE_MAX_SIZE * 2];
    _messages = new Message[_queueMaxSize];
    _messagesSwap = new Message[_queueMaxSize];
    // initialize message buffers
    for (unsigned int i = 0; i < _queueMaxSize; ++i) {
        _messages[i].message = _bufferMessages + i * _messageMaxSize;
        _messagesSwap[i].message = _bufferMessages + _queueMaxSize * _messageMaxSize + i * _messageMaxSize;
    }
    ::memset(&_dropMessageCounter, 0, sizeof(_dropMessageCounter));
    ::memset(&_queueMutex, 0, sizeof(_queueMutex));
    ::memset(&_logMutex, 0, sizeof(_logMutex));
    ::memset(&_condLog, 0, sizeof(_condLog));
    ::memset(&_condFlush, 0, sizeof(_condFlush));
    // default format
    setAllFormat(LOGGER_DEFAULT_FORMAT);
    // init thread
    if (pthread_mutex_init(&_queueMutex, NULL)) {
        throw Exception("pthread_mutex_init: ", strerror(errno));
    }
    if (pthread_mutex_init(&_logMutex, NULL)) {
        throw Exception("pthread_mutex_init: ", strerror(errno));
    }
    if (pthread_mutex_init(&_printMutex, NULL)) {
        throw Exception("pthread_mutex_init: ", strerror(errno));
    }
    if (pthread_cond_init(&_condLog, NULL)) {
        throw Exception("pthread_cond_init: ", strerror(errno));
    }
    if (pthread_cond_init(&_condFlush, NULL)) {
        throw Exception("pthread_cond_init: ", strerror(errno));
    }
    if (sem_init(&_queueSemaphore, 0, 0)) {
        throw Exception("sem_init: ", strerror(errno));
    }
    if (pthread_create(&_threadLogId, NULL, &_threadLogger, this)) {
        throw Exception("pthread_create: ", strerror(errno));
    }
}

inline Logger::~Logger() {
    _isStarted = false;
    // unlock thread
    sem_post(&_queueSemaphore);
    pthread_join(_threadLogId, NULL);
    // close and destroy sem + cond + mutex
    sem_close(&_queueSemaphore);
    sem_destroy(&_queueSemaphore);
    pthread_cond_destroy(&_condLog);
    pthread_cond_destroy(&_condFlush);
    pthread_mutex_destroy(&_queueMutex);
    pthread_mutex_destroy(&_logMutex);
    pthread_mutex_destroy(&_printMutex);
    // delete messageQueue
    delete[] _bufferMessages;
    delete[] _messages;
    delete[] _messagesSwap;

#ifdef LOGGER_PERF_DEBUG
    delete _perf;
#endif
}

inline void Logger::flush() {
    int semValue = 1;
    ::pthread_mutex_lock(&_queueMutex);
    while (_isStarted && semValue > 0) {
        ::sem_getvalue(&_queueSemaphore, &semValue);
        if (semValue == 0) {
            ::sem_post(&_queueSemaphore);
        }
        ::pthread_cond_wait(&_condFlush, &_queueMutex);
    }
    ::pthread_mutex_unlock(&_queueMutex);

    ::pthread_mutex_lock(&_printMutex);
    if (_pfile) {
        ::fflush(_pfile);
    }
    ::pthread_mutex_unlock(&_printMutex);
}

inline void* Logger::_threadLogger(void* e) {
    Logger* loggin = static_cast<Logger*>(e);
    loggin->_threadLog();
    return NULL;
}

static inline const char* s_levelToStr(const blet::Logger::ELevel& level) {
    const char* ret;
    switch (level) {
        case blet::Logger::EMERGENCY_LEVEL:
            ret = "EMERG";
            break;
        case blet::Logger::ALERT_LEVEL:
            ret = "ALERT";
            break;
        case blet::Logger::CRITICAL_LEVEL:
            ret = "CRIT";
            break;
        case blet::Logger::ERROR_LEVEL:
            ret = "ERROR";
            break;
        case blet::Logger::WARNING_LEVEL:
            ret = "WARN";
            break;
        case blet::Logger::NOTICE_LEVEL:
            ret = "NOTICE";
            break;
        case blet::Logger::INFO_LEVEL:
            ret = "INFO";
            break;
        case blet::Logger::DEBUG_LEVEL:
            ret = "DEBUG";
            break;
    }
    return ret;
}

inline void Logger::_printMessage(const Logger::Message& message) {
    const logger::Format& format = _formats[message.level];

    std::list<logger::Format::Action>::const_iterator cit;
    for (cit = format.actions.begin(); cit != format.actions.end(); ++cit) {
        switch (cit->action) {
            case logger::Format::PRINT_ACTION:
                fprintf(_pfile, cit->format.c_str(), 0);
                break;
            case logger::Format::NAME_ACTION:
                fprintf(_pfile, cit->format.c_str(), name.c_str());
                break;
            case logger::Format::LEVEL_ACTION:
                fprintf(_pfile, cit->format.c_str(), s_levelToStr(message.level));
                break;
            case logger::Format::PATH_ACTION:
                fprintf(_pfile, cit->format.c_str(), message.file);
                break;
            case logger::Format::FILE_ACTION:
                fprintf(_pfile, cit->format.c_str(), message.filename);
                break;
            case logger::Format::LINE_ACTION:
                fprintf(_pfile, cit->format.c_str(), message.line);
                break;
            case logger::Format::FUNC_ACTION:
                fprintf(_pfile, cit->format.c_str(), message.function);
                break;
            case logger::Format::PID_ACTION:
                fprintf(_pfile, cit->format.c_str(), format.pid);
                break;
            case logger::Format::TIME_ACTION: {
                char ftime[128];
                struct tm t;
#ifdef __GNUC__
                localtime_r(&(message.ts.tv_sec), &t);
#else
                localtime_s(&t, &(message.ts.tv_sec));
#endif
                strftime(ftime, sizeof(ftime), format.time.c_str(), &t);
                fprintf(_pfile, cit->format.c_str(), ftime);
                break;
            }
            case logger::Format::DECIMAL_ACTION:
                fprintf(_pfile, cit->format.c_str(), message.ts.tv_nsec / format.nsecDivisor);
                break;
            case logger::Format::MESSAGE_ACTION:
                fprintf(_pfile, cit->format.c_str(), message.message);
                break;
            case logger::Format::TID_ACTION:
                fprintf(_pfile, cit->format.c_str(), message.tid);
                break;
        }
    }
}

inline void Logger::_threadLog() {
    unsigned int lastMessageId;
    int lastDroppedNb = 0;
    timespec tsDropped;
    ::clock_gettime(CLOCK_REALTIME, &tsDropped);
    int semQueueValue = 1;
    unsigned int waitMoreMessages = 0;
    while (_isStarted || semQueueValue > 0) {
        sem_wait(&_queueSemaphore);
        pthread_mutex_lock(&_queueMutex);
        if (_currentMessageId == 0) {
            sem_getvalue(&_queueSemaphore, &semQueueValue);
            pthread_cond_signal(&_condLog);
            pthread_cond_broadcast(&_condFlush);
            pthread_mutex_unlock(&_queueMutex);
            continue;
        }
        if (waitMoreMessages < _queueMaxSize / 10 && _currentMessageId < _queueMaxSize / 10) {
            ++waitMoreMessages;
            pthread_mutex_unlock(&_queueMutex);
            sem_post(&_queueSemaphore);
            continue;
        }
        waitMoreMessages = 0;

        // swap messages
        Message* tmp = _messages;
        _messages = _messagesSwap;
        _messagesSwap = tmp;
        // save last message id
        lastMessageId = _currentMessageId;
        // reset current message id
        _currentMessageId = 0;
        pthread_cond_signal(&_condLog);
        timespec currentTime;
        ::clock_gettime(CLOCK_REALTIME, &currentTime);
        if (currentTime.tv_sec > tsDropped.tv_sec) {
            tsDropped.tv_sec = currentTime.tv_sec;
            unsigned int messageDroppedCount = -lastDroppedNb;
            for (int i = 0; i < (int)(sizeof(_dropMessageCounter) / sizeof(*_dropMessageCounter)); ++i) {
                messageDroppedCount += _dropMessageCounter[i];
            }
            if (messageDroppedCount > 0) {
#ifdef LOGGER_PERF_DEBUG
                _perf->messageCount += messageDroppedCount;
#endif
                _M_logFormat("Message(s) dropped: %u", messageDroppedCount);
                _M_logInfos(WARNING_LEVEL, __FILE__, (::strrchr(__FILE__, _LOGGER_SEPARATOR_PATH) + 1), 0,
                            _LOGGER_FUNCTION_NAME);
                // move index
                ++_currentMessageId;
                lastDroppedNb += messageDroppedCount;
            }
        }
        pthread_mutex_unlock(&_queueMutex);

        // call print function
        pthread_mutex_lock(&_printMutex);
        if (_printMethods) {
            for (unsigned int i = 0; i < lastMessageId; ++i) {
                (this->*_printMethods)(_messagesSwap[i]);
#ifdef LOGGER_PERF_DEBUG
                ++_perf->messagePrinted;
#endif
            }
        }
        pthread_mutex_unlock(&_printMutex);

        pthread_cond_broadcast(&_condFlush);
    }

    unsigned int messageDroppedCount = -lastDroppedNb;
    for (int i = 0; i < (int)(sizeof(_dropMessageCounter) / sizeof(*_dropMessageCounter)); ++i) {
        messageDroppedCount += _dropMessageCounter[i];
    }
    if (messageDroppedCount > 0) {
#ifdef LOGGER_PERF_DEBUG
        _perf->messageCount += messageDroppedCount;
#endif
        _M_logFormat("Message(s) dropped: %u", messageDroppedCount);
        _M_logInfos(WARNING_LEVEL, __FILE__, (::strrchr(__FILE__, _LOGGER_SEPARATOR_PATH) + 1), 0,
                    _LOGGER_FUNCTION_NAME);
        pthread_mutex_lock(&_printMutex);
        if (_printMethods) {
            (this->*_printMethods)(_messages[0]);
#ifdef LOGGER_PERF_DEBUG
            ++_perf->messagePrinted;
#endif
        }
        pthread_mutex_unlock(&_printMutex);
    }
}

inline void Logger::_printFILE(const Message& message) {
    _printMessage(message);
}

inline void Logger::_printSyslog(const Message& message) {
    ::syslog(message.level, "%s", message.message);
}

inline void Logger::_printUser(const Message& message) {
    _userPrintFunction(_userData, name, message);
}

inline void Logger::_printFILEUser(const Message& message) {
    _printFILE(message);
    _printUser(message);
}

inline void Logger::_printFILESyslog(const Message& message) {
    _printFILE(message);
    _printSyslog(message);
}

inline void Logger::_printUserSyslog(const Message& message) {
    _printUser(message);
    _printSyslog(message);
}

inline void Logger::_printFILEUserSyslog(const Message& message) {
    _printFILE(message);
    _printUser(message);
    _printSyslog(message);
}

inline void Logger::_choosePrintMethod() {
    // create flag
    int flag = 0;
    if (_pfile) {
        flag += 1 << 0;
    }
    if (_toSyslog) {
        flag += 1 << 1;
    }
    if (_userPrintFunction) {
        flag += 1 << 2;
    }
    switch (flag) {
        case 1:
            _printMethods = &Logger::_printFILE;
            break;
        case 2:
            _printMethods = &Logger::_printSyslog;
            break;
        case 3:
            _printMethods = &Logger::_printFILESyslog;
            break;
        case 4:
            _printMethods = &Logger::_printUser;
            break;
        case 5:
            _printMethods = &Logger::_printFILEUser;
            break;
        case 6:
            _printMethods = &Logger::_printUserSyslog;
            break;
        case 7:
            _printMethods = &Logger::_printFILEUserSyslog;
            break;
        default:
            _printMethods = NULL;
            break;
    }
}

inline void Logger::setLevelFormat(const ELevel& level, const char* format) {
    pthread_mutex_lock(&_queueMutex);
    _formats[level] = logger::Format(name, format);
    pthread_mutex_unlock(&_queueMutex);
}

inline void Logger::setAllFormat(const char* format) {
    pthread_mutex_lock(&_queueMutex);
    logger::Format fmt = logger::Format(name, format);
    for (int i = 0; i < static_cast<int>(sizeof(_formats) / sizeof(*_formats)); ++i) {
        _formats[i] = fmt;
    }
    pthread_mutex_unlock(&_queueMutex);
}

inline void Logger::setFILE(FILE* file) {
    ::pthread_mutex_lock(&_printMutex);
    _pfile = file;
    _choosePrintMethod();
    ::pthread_mutex_unlock(&_printMutex);
}

inline void Logger::setSyslog(bool active) {
    ::pthread_mutex_lock(&_printMutex);
    _toSyslog = active;
    _choosePrintMethod();
    ::pthread_mutex_unlock(&_printMutex);
}

inline void Logger::setUserPrintFunction(printfunction_t printFunction, void* userData) {
    ::pthread_mutex_lock(&_printMutex);
    _userPrintFunction = printFunction;
    _userData = userData;
    _choosePrintMethod();
    ::pthread_mutex_unlock(&_printMutex);
}

inline void Logger::logSync(ELevel level, const char* format, ...) {
    ::pthread_mutex_lock(&_logMutex);
    // char message[LOGGER_MESSAGE_MAX_SIZE];
    Message msg;
    msg.message = reinterpret_cast<char*>(const_cast<char*>(format));

    ::clock_gettime(CLOCK_REALTIME, &msg.ts);

    va_list vargs;
    va_start(vargs, format);
    ::vsnprintf(msg.message, _messageMaxSize, format, vargs);
    va_end(vargs);

    // create a new message
    msg.level = level;
    msg.file = NULL;
    msg.filename = NULL;
    msg.line = 0;
    msg.function = NULL;

    // printMessage(msg);
    ::pthread_mutex_unlock(&_logMutex);
}

inline void Logger::vlog(ELevel level, const char* format, va_list& vargs) {
    ::pthread_mutex_lock(&_logMutex);
    ::pthread_mutex_lock(&_queueMutex);
#ifdef LOGGER_ASYNC_WAIT_PRINT
    if (_currentMessageId >= _queueMaxSize - 1) {
        ::pthread_cond_wait(&_condLog, &_queueMutex);
    }
#endif

    if (_currentMessageId == 0) {
        ::sem_post(&_queueSemaphore);
    }

    ::clock_gettime(CLOCK_REALTIME, &_messages[_currentMessageId].ts);

    // copy formated message
    ::vsnprintf(_messages[_currentMessageId].message, _messageMaxSize, format, vargs);

    // create a new message
    _messages[_currentMessageId].level = level;
    _messages[_currentMessageId].file = NULL;
    _messages[_currentMessageId].filename = NULL;
    _messages[_currentMessageId].line = 0;
    _messages[_currentMessageId].function = NULL;

    // move index
    ++_currentMessageId;
#ifndef LOGGER_ASYNC_WAIT_PRINT
    if (_currentMessageId == _queueMaxSize) {
        _currentMessageId = 0;
    }
#endif

#ifdef LOGGER_PERF_DEBUG
    ++_perf->messageCount;
#endif
    ::pthread_mutex_unlock(&_queueMutex);
    ::pthread_mutex_unlock(&_logMutex);
}

inline void Logger::log(ELevel level, const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(level, format, vargs);
    va_end(vargs);
}

inline void Logger::emergency(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(EMERGENCY_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::alert(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(ALERT_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::critical(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(CRITICAL_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::error(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(ERROR_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::warning(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(WARNING_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::notice(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(NOTICE_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::info(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(INFO_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::debug(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(DEBUG_LEVEL, format, vargs);
    va_end(vargs);
}

inline void Logger::_M_logFormat(const char* format, ...) {
    // copy formated message
    va_list vargs;
    va_start(vargs, format);
    ::vsnprintf(_messages[_currentMessageId].message, _messageMaxSize, format, vargs);
    va_end(vargs);
}

inline void Logger::_M_logStream(const ::std::ostringstream& oss) {
    std::string str = oss.str();
    unsigned int cpySize = _messageMaxSize < str.size() ? _messageMaxSize : str.size() + 1;
    ::memcpy(_messages[_currentMessageId].message, str.c_str(), cpySize);
    if (cpySize == _messageMaxSize) {
        _messages[_currentMessageId].message[_messageMaxSize - 1] = '\0';
    }
}

inline void Logger::_M_logInfos(ELevel level, const char* file, const char* filename, int line, const char* function) {
#ifdef LOGGER_PERF_DEBUG
    ++_perf->messageCount;
#endif

    ::clock_gettime(CLOCK_REALTIME, &_messages[_currentMessageId].ts);

    // create a new message
    _messages[_currentMessageId].level = level;
    _messages[_currentMessageId].file = file;
    _messages[_currentMessageId].filename = filename;
    _messages[_currentMessageId].line = line;
    _messages[_currentMessageId].function = function;
    _messages[_currentMessageId].tid = ::pthread_self();
    if (_userPrintFunction) {
        _messages[_currentMessageId].pid = ::getpid();
    }

    if (_currentMessageId == 0) {
        ::sem_post(&_queueSemaphore);
    }
}

} // namespace blet

// ------------------
// End src/logger.cpp
// ------------------

// ---------------------------
// Start src/logger/format.cpp
// ---------------------------
// #include "blet/logger/format.h" (already included)

#include <stdio.h>
#include <unistd.h>

#include <iostream>
#include <list>
#include <map>
#include <sstream>

#define LOGGER_OPEN_BRACE static_cast<char>(-41)
#define LOGGER_SEPARATOR static_cast<char>(-42)
#define LOGGER_CLOSE_BRACE static_cast<char>(-43)

#ifndef LOGGER_DEFAULT_TIME_FORMAT
#define LOGGER_DEFAULT_TIME_FORMAT "%x %X"
#endif

namespace blet {

namespace logger {

static inline void s_formatSerialize(std::string& str) {
    for (std::size_t i = 0; i < str.size(); ++i) {
        if (i > 0 && str[i - 1] == '\\') {
            if (str[i] == '\\') {
                str.erase(i - 1, 1);
            }
            else {
                --i;
                str.erase(i, 1);
            }
        }
        else if (str[i] == '{') {
            str[i] = LOGGER_OPEN_BRACE;
        }
        else if (str[i] == ':') {
            str[i] = LOGGER_SEPARATOR;
        }
        else if (str[i] == '}') {
            str[i] = LOGGER_CLOSE_BRACE;
        }
    }
}

static inline void s_formatDeserialize(std::string& str) {
    for (std::size_t i = 0; i < str.size(); ++i) {
        switch (str[i]) {
            case LOGGER_OPEN_BRACE:
                str[i] = '{';
                break;
            case LOGGER_SEPARATOR:
                str[i] = ':';
                break;
            case LOGGER_CLOSE_BRACE:
                str[i] = '}';
                break;
        }
    }
}

static inline void s_escapePercent(std::string& str) {
    for (std::size_t i = 0; i < str.size(); ++i) {
        if (str[i] == '%') {
            str.insert(i, "%");
            ++i;
        }
    }
}

static inline Format::EAction s_nameToEnumAction(const std::string& name) {
    static const std::pair<std::string, Format::EAction> nameToActionPairs[] = {
        std::pair<std::string, Format::EAction>("name", Format::NAME_ACTION),
        std::pair<std::string, Format::EAction>("level", Format::LEVEL_ACTION),
        std::pair<std::string, Format::EAction>("path", Format::PATH_ACTION),
        std::pair<std::string, Format::EAction>("file", Format::FILE_ACTION),
        std::pair<std::string, Format::EAction>("line", Format::LINE_ACTION),
        std::pair<std::string, Format::EAction>("func", Format::FUNC_ACTION),
        std::pair<std::string, Format::EAction>("pid", Format::PID_ACTION),
        std::pair<std::string, Format::EAction>("time", Format::TIME_ACTION),
        std::pair<std::string, Format::EAction>("decimal", Format::DECIMAL_ACTION),
        std::pair<std::string, Format::EAction>("message", Format::MESSAGE_ACTION),
        std::pair<std::string, Format::EAction>("tid", Format::TID_ACTION)};
    static const std::map<std::string, Format::EAction> nameToEnumAction(
        nameToActionPairs, nameToActionPairs + sizeof(nameToActionPairs) / sizeof(*nameToActionPairs));

    std::map<std::string, Format::EAction>::const_iterator cit = nameToEnumAction.find(name);
    if (cit == nameToEnumAction.end()) {
        return Format::PRINT_ACTION;
    }
    return cit->second;
}

static inline const char* s_idToDefaultFormat(const Format::EAction& id) {
    const char* ret = NULL;
    switch (id) {
        case Format::PRINT_ACTION:
            ret = "unknown";
            break;
        case Format::NAME_ACTION:
            ret = "%s";
            break;
        case Format::LEVEL_ACTION:
            ret = "%s";
            break;
        case Format::PATH_ACTION:
            ret = "%s";
            break;
        case Format::FILE_ACTION:
            ret = "%s";
            break;
        case Format::LINE_ACTION:
            ret = "%d";
            break;
        case Format::FUNC_ACTION:
            ret = "%s";
            break;
        case Format::PID_ACTION:
            ret = "%d";
            break;
        case Format::TID_ACTION:
            ret = "%X";
            break;
        case Format::TIME_ACTION:
            ret = "%s";
            break;
        case Format::DECIMAL_ACTION:
            ret = "%d";
            break;
        case Format::MESSAGE_ACTION:
            ret = "%s";
            break;
    }
    return ret;
}

static inline int s_getDecimalDivisor(const std::string& format) {
    int value = 1;
    std::size_t percentPos = format.find('%');
    if (percentPos != format.npos) {
        int log_10;
        std::stringstream ss("");
        ss << format.c_str() + percentPos + 1;
        ss >> log_10;
        if (log_10 < 0) {
            log_10 = -log_10;
        }
        log_10 = 9 - log_10;
        for (int i = 0; i < log_10; ++i) {
            value *= 10;
        }
    }
    return value;
}

static inline const char* s_nameToColorFormat(const std::string& name) {
    static const std::pair<std::string, const char*> nameToColorPairs[] = {
        std::pair<std::string, const char*>("color_reset", "\033[0m"),
        std::pair<std::string, const char*>("color_bold", "\033[1m"),
        std::pair<std::string, const char*>("color_dim", "\033[2m"),
        std::pair<std::string, const char*>("color_italic", "\033[3m"),
        std::pair<std::string, const char*>("color_underline", "\033[4m"),
        std::pair<std::string, const char*>("color_blink", "\033[5m"),
        std::pair<std::string, const char*>("color_rev", "\033[7m"),
        std::pair<std::string, const char*>("color_hide", "\033[8m"),
        std::pair<std::string, const char*>("fg_black", "\033[30m"),
        std::pair<std::string, const char*>("fg_red", "\033[31m"),
        std::pair<std::string, const char*>("fg_green", "\033[32m"),
        std::pair<std::string, const char*>("fg_yellow", "\033[33m"),
        std::pair<std::string, const char*>("fg_blue", "\033[34m"),
        std::pair<std::string, const char*>("fg_magenta", "\033[35m"),
        std::pair<std::string, const char*>("fg_cyan", "\033[36m"),
        std::pair<std::string, const char*>("fg_white", "\033[37m"),
        std::pair<std::string, const char*>("bg_black", "\033[40m"),
        std::pair<std::string, const char*>("bg_red", "\033[41m"),
        std::pair<std::string, const char*>("bg_green", "\033[42m"),
        std::pair<std::string, const char*>("bg_yellow", "\033[43m"),
        std::pair<std::string, const char*>("bg_blue", "\033[44m"),
        std::pair<std::string, const char*>("bg_magenta", "\033[45m"),
        std::pair<std::string, const char*>("bg_cyan", "\033[46m"),
        std::pair<std::string, const char*>("bg_white", "\033[47m")};
    static const std::map<std::string, const char*> nameToColorFormat(
        nameToColorPairs, nameToColorPairs + sizeof(nameToColorPairs) / sizeof(*nameToColorPairs));

    const char* ret = "";
    std::map<std::string, const char*>::const_iterator cit = nameToColorFormat.find(name);
    if (cit != nameToColorFormat.end()) {
        ret = cit->second;
    }
    return ret;
}

inline Format::Format() :
    originFormat(""),
    time(""),
    threadId(0),
    pid(0),
    nsecDivisor(1) {}

inline Format::Format(const std::string& loggerName, const char* format) :
    originFormat(format),
    time(""),
    threadId(0),
    pid(0),
    nsecDivisor(1) {
    std::string sFormat(format);
    // transform "{:}" non escape characters
    s_formatSerialize(sFormat);
    // search first occurence of '{'
    std::size_t lastIndexStart = 0;
    std::size_t indexStart = sFormat.find(LOGGER_OPEN_BRACE);
    std::size_t indexEnd;
    std::size_t indexFormat;
    while (indexStart != std::string::npos) {
        // search first occurrence of '}' after indexStart
        indexEnd = sFormat.find(LOGGER_CLOSE_BRACE, indexStart);
        if (indexEnd == std::string::npos) {
            break;
        }
        // substr the part before key
        if (lastIndexStart - indexStart > 0) {
            std::string beforeKey = sFormat.substr(lastIndexStart, indexStart - lastIndexStart);
            s_formatDeserialize(beforeKey);
            s_escapePercent(beforeKey);
            actions.push_back(Action(PRINT_ACTION, beforeKey));
        }
        lastIndexStart = indexEnd + 1;
        // search first occurrence of ':' after indexStart
        indexFormat = sFormat.find(LOGGER_SEPARATOR, indexStart);
        // if ':' not found or ':' is not between '{' and '}'
        if (indexFormat == std::string::npos || indexFormat > indexEnd) {
            // get name of key {[...]}
            std::string key = sFormat.substr(indexStart + 1, indexEnd - indexStart - 1);
            // get the id of key
            EAction actionId = s_nameToEnumAction(key);
            if (actionId != PRINT_ACTION) {
                switch (actionId) {
                    case PID_ACTION:
                        pid = ::getpid();
                        break;
                    case TID_ACTION:
                        threadId = ::pthread_self();
                        break;
                    case TIME_ACTION:
                        time = LOGGER_DEFAULT_TIME_FORMAT;
                        break;
                    default:
                        break;
                }
                actions.push_back(Action(actionId, s_idToDefaultFormat(actionId)));
            }
            else {
                // check if color
                const char* color = s_nameToColorFormat(key);
                actions.push_back(Action(PRINT_ACTION, color));
            }
            indexStart = sFormat.find(LOGGER_OPEN_BRACE, indexStart + 1);
            // find other key
            continue;
        }
        else {
            // get name of key {[...]:...}
            std::string key = sFormat.substr(indexStart + 1, indexFormat - indexStart - 1);
            // get format of key {...:[...]}
            std::string formatKey = sFormat.substr(indexFormat + 1, indexEnd - indexFormat - 1);
            // replace no print character by real
            s_formatDeserialize(formatKey);
            // get the id of key
            EAction actionId = s_nameToEnumAction(key);
            if (actionId != PRINT_ACTION) {
                switch (actionId) {
                    case PID_ACTION:
                        pid = ::getpid();
                        break;
                    case TID_ACTION:
                        threadId = ::pthread_self();
                        break;
                    case TIME_ACTION:
                        time = formatKey;
                        formatKey = "%s";
                        break;
                    case DECIMAL_ACTION:
                        nsecDivisor = s_getDecimalDivisor(formatKey);
                        break;
                    default:
                        break;
                }
                actions.push_back(Action(actionId, formatKey));
            }
            else {
                s_escapePercent(formatKey);
                actions.push_back(Action(PRINT_ACTION, formatKey));
            }
            // parse other key
            indexStart = sFormat.find(LOGGER_OPEN_BRACE, indexStart + 1);
            continue;
        }
    }
    // get last characters in format
    if (lastIndexStart - sFormat.size() > 0) {
        std::string lastFormat = sFormat.substr(lastIndexStart, sFormat.size() - lastIndexStart);
        s_formatDeserialize(lastFormat);
        s_escapePercent(lastFormat);
        actions.push_back(Action(PRINT_ACTION, lastFormat));
    }
    // search if message is exist
    std::list<Action>::iterator it;
    for (it = actions.begin(); it != actions.end(); ++it) {
        if (it->action == MESSAGE_ACTION) {
            break;
        }
    }
    // add message action if not exist
    if (it == actions.end()) {
        actions.push_back(Action(MESSAGE_ACTION, s_idToDefaultFormat(MESSAGE_ACTION)));
    }
    // add \n on last action
    actions.push_back(Action(PRINT_ACTION, "\n"));
    // compress actions
    it = actions.begin();
    while (it != actions.end()) {
        // replace action by string
        if (it->action == NAME_ACTION || it->action == PID_ACTION) {
            char buffer[128];
            switch (it->action) {
                case NAME_ACTION:
                    ::snprintf(buffer, sizeof(buffer), it->format.c_str(), loggerName.c_str());
                    break;
                case PID_ACTION:
                    ::snprintf(buffer, sizeof(buffer), it->format.c_str(), pid);
                    break;
                default:
                    break;
            }
            std::string str(buffer);
            s_escapePercent(str);
            it->action = PRINT_ACTION;
            it->format = str;
        }
        std::list<Action>::iterator prev = it;
        ++it;
        if (prev->action == PRINT_ACTION) {
            // concat with next if exist
            if (it != actions.end()) {
                it->format = prev->format + it->format;
                it = actions.erase(prev);
            }
            // concat with prev
            else {
                --it;
                --it;
                std::list<Action>::iterator prev = it;
                ++it;
                prev->format = prev->format + it->format;
                it = actions.erase(it);
            }
        }
    }
}

inline Format::~Format() {}

} // namespace logger

} // namespace blet

#undef LOGGER_OPEN_BRACE
#undef LOGGER_SEPARATOR
#undef LOGGER_CLOSE_BRACE

// -------------------------
// End src/logger/format.cpp
// -------------------------

#endif // #ifndef _AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_LOGGER_H_