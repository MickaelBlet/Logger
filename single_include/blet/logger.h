// Generated by amalgamate.py
#ifndef _AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_LOGGER_H_
#define _AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_LOGGER_H_

// ---------------------------
// Start include/blet/logger.h
// ---------------------------
/**
 * logger.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2023 BLET Mickaël.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef _BLET_LOGGER_H_
#define _BLET_LOGGER_H_

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <time.h>

#include <exception>
#include <map>
#include <sstream>
#include <string>

// #include "logger/format.h"
// ----------------------------------
// Start include/blet/logger/format.h
// ----------------------------------

/**
 * logger/format.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2023 BLET Mickaël.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef _BLET_LOGGER_FORMAT_H_
#define _BLET_LOGGER_FORMAT_H_

#include <pthread.h>

#include <list>
#include <string>

namespace blet {

namespace logger {

struct Format {
    enum eAction {
        PRINT_ACTION = 0,
        NAME_ACTION = 1,
        LEVEL_ACTION = 2,
        PATH_ACTION = 3,
        FILE_ACTION = 4,
        LINE_ACTION = 5,
        FUNC_ACTION = 6,
        PID_ACTION = 7,
        TIME_ACTION = 8,
        DECIMAL_ACTION = 9,
        MESSAGE_ACTION = 10,
        TID_ACTION = 11
    };

    Format();
    Format(const std::string& loggerName, const char* format);
    ~Format();

    std::string time;
    pid_t pid;
    pthread_t threadId;
    int nsecDivisor;

    struct Action {
        inline Action(eAction action_, const std::string& format_) :
            action(action_),
            format(format_) {}
        eAction action;
        std::string format;
    };

    std::list<Action> actions;
};

} // namespace logger

} // namespace blet

#endif // #ifndef _BLET_LOGGER_FORMAT_H_

// --------------------------------
// End include/blet/logger/format.h
// --------------------------------

// -----------------------------
// Content include/blet/logger.h
// -----------------------------

#if defined _WIN32 || defined _WIN64 || defined __CYGWIN__
#define _LOGGER_SEPARATOR_PATH '\\'
#else
#define _LOGGER_SEPARATOR_PATH '/'
#endif

#if defined _WIN32 || defined _WIN64
#define _LOGGER_FUNCTION_NAME __FUNCTION__
#else
#define _LOGGER_FUNCTION_NAME __func__
#endif

#define _LOGGER_FILENAME (const char*)(::strrchr(__FILE__, _LOGGER_SEPARATOR_PATH) + 1)
#define _LOGGER_FILE_INFOS __FILE__, _LOGGER_FILENAME, __LINE__, _LOGGER_FUNCTION_NAME

#define LOGGER_MAIN() ::blet::Logger::getMain()

#ifndef __GNUC__
#ifndef __attribute__
#define __attribute__(X) /* do nothing */
#endif
#endif

#ifdef LOGGER_VARIADIC_MACRO

#define _LOGGER_LOG_FMT(logger, level, ...)                  \
    do {                                                     \
        if (logger.isPrintable(level) && logger._M_lock()) { \
            logger._M_logFormat(##__VA_ARGS__);              \
            logger._M_logInfos(level, _LOGGER_FILE_INFOS);   \
            logger._M_unlock();                              \
        }                                                    \
    } while (0)

#define LOGGER_EMERG_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::EMERGENCY, __VA_ARGS__)
#define LOGGER_ALERT_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::ALERT, __VA_ARGS__)
#define LOGGER_CRIT_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::CRITICAL, __VA_ARGS__)
#define LOGGER_ERROR_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::ERROR, __VA_ARGS__)
#define LOGGER_WARN_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::WARNING, __VA_ARGS__)
#define LOGGER_NOTICE_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::NOTICE, __VA_ARGS__)
#define LOGGER_INFO_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::INFO, __VA_ARGS__)
#define LOGGER_DEBUG_FMT(...) _LOGGER_LOG_FMT(LOGGER_MAIN(), blet::Logger::DEBUG, __VA_ARGS__)

#endif

/**
 * @brief Use format method for get the custom message
 */
#define _LOGGER_LOG_FMT_P(logger, level, parenthesis_msg)    \
    do {                                                     \
        if (logger.isPrintable(level) && logger._M_lock()) { \
            logger._M_logFormat parenthesis_msg;             \
            logger._M_logInfos(level, _LOGGER_FILE_INFOS);   \
            logger._M_unlock();                              \
        }                                                    \
    } while (0)

#define LOGGER_EMERG_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::EMERGENCY, parenthesis_msg)
#define LOGGER_ALERT_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::ALERT, parenthesis_msg)
#define LOGGER_CRIT_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::CRITICAL, parenthesis_msg)
#define LOGGER_ERROR_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::ERROR, parenthesis_msg)
#define LOGGER_WARN_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::WARNING, parenthesis_msg)
#define LOGGER_NOTICE_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::NOTICE, parenthesis_msg)
#define LOGGER_INFO_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::INFO, parenthesis_msg)
#define LOGGER_DEBUG_FMT_P(parenthesis_msg) _LOGGER_LOG_FMT_P(LOGGER_MAIN(), ::blet::Logger::DEBUG, parenthesis_msg)

/**
 * @brief Use format method for get the custom message
 */
#define _LOGGER_LOG(logger, level, stream)                   \
    do {                                                     \
        if (logger.isPrintable(level) && logger._M_lock()) { \
            ::std::ostringstream __loggerTmpOss("");         \
            __loggerTmpOss << stream;                        \
            logger._M_logStream(__loggerTmpOss);             \
            logger._M_logInfos(level, _LOGGER_FILE_INFOS);   \
            logger._M_unlock();                              \
        }                                                    \
    } while (0)

#define LOGGER_EMERG(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::EMERGENCY, stream)
#define LOGGER_ALERT(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::ALERT, stream)
#define LOGGER_CRIT(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::CRITICAL, stream)
#define LOGGER_ERROR(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::ERROR, stream)
#define LOGGER_WARN(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::WARNING, stream)
#define LOGGER_NOTICE(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::NOTICE, stream)
#define LOGGER_INFO(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::INFO, stream)
#define LOGGER_DEBUG(stream) _LOGGER_LOG(LOGGER_MAIN(), ::blet::Logger::DEBUG, stream)

#define LOGGER_TO_EMERG(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::EMERGENCY, stream)
#define LOGGER_TO_ALERT(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::ALERT, stream)
#define LOGGER_TO_CRIT(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::CRITICAL, stream)
#define LOGGER_TO_ERROR(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::ERROR, stream)
#define LOGGER_TO_WARN(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::WARNING, stream)
#define LOGGER_TO_NOTICE(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::NOTICE, stream)
#define LOGGER_TO_INFO(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::INFO, stream)
#define LOGGER_TO_DEBUG(logger, stream) _LOGGER_LOG(logger, ::blet::Logger::DEBUG, stream)

#define LOGGER_FLUSH() LOGGER_MAIN().flush()
#define LOGGER_TO_FLUSH(logger) logger.flush()

// OPTIONS
#ifndef LOGGER_DROP_OVERFLOW
#define LOGGER_ASYNC_WAIT_PRINT 1
#endif

#ifndef LOGGER_QUEUE_SIZE
#define LOGGER_QUEUE_SIZE 1024
#endif

#ifndef LOGGER_MESSAGE_MAX_SIZE
#define LOGGER_MESSAGE_MAX_SIZE 2048
#endif

#ifndef LOGGER_DEFAULT_FORMAT
#define LOGGER_DEFAULT_FORMAT \
    "{level:%-6s} [{pid}:{tid}] {name:%10s}: {time}.{decimal:%03d}:{file: %25s:}{line:%-3d} {message}"
#endif

// name, level, path, file, line, func, pid, time, message, microsec, millisec, nanosec

namespace blet {

class Logger {
  public:
    class Exception : public std::exception {
      public:
        inline Exception(const char* s1, const char* s2 = "", const char* s3 = "") {
            _str = s1;
            _str += s2;
            _str += s3;
        }
        inline virtual ~Exception() throw() {}
        inline const char* what() const throw() {
            return _str.c_str();
        }

      protected:
        std::string _str;
    };

    enum eLevel {
        EMERGENCY = LOG_EMERG,
        ALERT = LOG_ALERT,
        CRITICAL = LOG_CRIT,
        ERROR = LOG_ERR,
        WARNING = LOG_WARNING,
        NOTICE = LOG_NOTICE,
        INFO = LOG_INFO,
        DEBUG = LOG_DEBUG
    };

    struct Message {
        eLevel level;
        struct timespec ts;
        const char* file;
        const char* filename;
        const char* function;
        int line;
        char* message;
    };

    Logger(const char* name, unsigned int queueMaxSize = LOGGER_QUEUE_SIZE,
           unsigned int messageMaxSize = LOGGER_MESSAGE_MAX_SIZE);
    ~Logger();

    static inline Logger& getMain() {
        static Logger logger("main");
        return logger;
    }

    inline bool isPrintable(const eLevel& level) {
        return (1 << level) & _levelFilter;
    }

    inline bool _M_lock() {
        bool ret = true;

#ifdef LOGGER_ASYNC_WAIT_PRINT
        ::pthread_mutex_lock(&_logMutex);
        ::pthread_mutex_lock(&_queueMutex);
        if (_currentMessageId >= _queueMaxSize - 1) {
            ::pthread_cond_wait(&_condLog, &_queueMutex);
        }
#else
        // without lock
        if (_currentMessageId >= _queueMaxSize - 1) {
            ret = false;
            ++_droppedMessageNb;
        }
        else {
            ::pthread_mutex_lock(&_logMutex);
            ::pthread_mutex_lock(&_queueMutex);
            // with lock
            if (_currentMessageId >= _queueMaxSize - 1) {
                ::pthread_mutex_unlock(&_queueMutex);
                ::pthread_mutex_unlock(&_logMutex);
                ret = false;
                ++_droppedMessageNb;
            }
        }
#endif
        return ret;
    }

    inline void _M_unlock() {
        // move index
        ++_currentMessageId;
        ::pthread_mutex_unlock(&_queueMutex);
        ::pthread_mutex_unlock(&_logMutex);
    }

    inline void enableLevel(const eLevel& level) {
        _levelFilter |= (1 << level);
    }
    inline void disableLevel(const eLevel& level) {
        _levelFilter &= ~(1 << level);
    }

    void flush();

    /**
     * @brief Set format of type
     * {asctime}
     * {filename}
     * {funcname}
     * {levelname}
     * {lineno}
     * {process}
     * {message}
     * {name}
     * {pathname}
     * {thread}
     *
     * @param level
     * @param format
     */
    void setTypeFormat(const eLevel& level, const char* format);

    /**
     * @brief Set all format type.
     * keywords:
     * - name: name of logger
     * - level: level of log
     * - path: __FILE__ of log
     * - file: filename of log
     * - line: __LINE__ of log
     * - func: __func__ of log
     * - pid: process id
     * - time: datetime of log
     * - message: format message of log
     * - microsec: micro seconds
     * - millisec: milli seconds
     * - nanosec: nano seconds
     *
     * @param format C string of format.
     */
    void setAllFormat(const char* format);

    void setFILE(FILE* file);

    __attribute__((__format__(__printf__, 3, 4))) void logSync(eLevel level, const char* format, ...);
    void vlog(eLevel level, const char* format, va_list& vargs);
    __attribute__((__format__(__printf__, 3, 4))) void log(eLevel level, const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void emergency(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void alert(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void critical(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void error(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void warning(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void notice(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void info(const char* format, ...);
    __attribute__((__format__(__printf__, 2, 3))) void debug(const char* format, ...);

    /**
     * @brief It's follow by _M_logInfos
     */
    __attribute__((__format__(__printf__, 2, 3))) void _M_logFormat(const char* format, ...);

    /**
     * @brief It's follow by _M_logInfos
     */
    void _M_logStream(const ::std::ostringstream& os);

    /**
     * @brief It's prev by _M_logFormat or _M_logStream
     *
     * @param level
     * @param file
     * @param filename
     * @param line
     * @param function
     */
    void _M_logInfos(eLevel level, const char* file, const char* filename, int line, const char* function);

    void printMessage(const Message& message);

    const std::string name;

  private:
    inline Logger(const Logger&) :
        _messageMaxSize(0),
        _queueMaxSize(0){}; // disable copy
    inline Logger& operator=(const Logger&) {
        return *this;
    }; // disable copy

    struct DebugPerf {
        inline DebugPerf(const char* name_) :
            name(name_),
            messageCount(0),
            messagePrinted(0) {
            clock_gettime(CLOCK_MONOTONIC, &startTime);
        }
        inline ~DebugPerf() {
            ::timespec endTs;
            clock_gettime(CLOCK_MONOTONIC, &endTs);
            if ((endTs.tv_nsec - startTime.tv_nsec) < 0) {
                endTs.tv_nsec = 1000000000 + (endTs.tv_nsec - startTime.tv_nsec);
                endTs.tv_sec -= 1;
            }
            else {
                endTs.tv_nsec = endTs.tv_nsec - startTime.tv_nsec;
            }
            fprintf(stderr, "LOGGER_PERF %s:\n", name.c_str());
            fprintf(stderr, "- Time: %ld.%09ld\n", (endTs.tv_sec - startTime.tv_sec), endTs.tv_nsec);
            fprintf(stderr, "- Message counted: %u\n", messageCount);
            fprintf(stderr, "- Message printed: %u\n", messagePrinted);
            fprintf(stderr, "- Message lost: %u\n", messageCount - messagePrinted);
            fprintf(stderr, "- Message rate: %f\n",
                    messagePrinted / ((endTs.tv_sec - startTime.tv_sec) * 1000000000.0 + endTs.tv_nsec) * 1000000000);
            fflush(stderr);
        }
        std::string name;
        ::timespec startTime;
        unsigned int messageCount;
        unsigned int messagePrinted;
    };

    static void* _threadLogger(void* e);
    void _threadLog();

    bool _isStarted;
    unsigned int _currentMessageId;
    unsigned int _droppedMessageNb;
    pthread_mutex_t _queueMutex;
    pthread_mutex_t _logMutex;
    pthread_mutex_t _droppedMutex;
    pthread_cond_t _condLog;
    pthread_cond_t _condFlush;
    sem_t _queueSemaphore;
    sem_t _droppedMessageSemaphore;
    pthread_t _threadLogId;
    int _levelFilter;

    FILE* _pfile;

    const unsigned int _messageMaxSize;
    const unsigned int _queueMaxSize;
    char* _bufferMessages;
    Message* _messages;
    Message* _messagesSwap;

    logger::Format* _formats;

    DebugPerf* _perf;
};

} // namespace blet

#endif // #ifndef _BLET_LOGGER_H_

// -------------------------
// End include/blet/logger.h
// -------------------------

// --------------------
// Start src/logger.cpp
// --------------------
/**
 * logger.cpp
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2023 BLET Mickaël.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// #include "blet/logger.h" (already included)

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

#include <iostream>
#include <list>
#include <map>
#include <string>
#include <vector>

#ifdef LOGGER_COLOR_LEVELS
#define LOGGER_EMERGENCY_FORMAT "{bg_magenta}{fg_black}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#define LOGGER_ALERT_FORMAT "{fg_magenta}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#define LOGGER_CRITICAL_FORMAT "{bg_red}{fg_black}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#define LOGGER_ERROR_FORMAT "{fg_red}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#define LOGGER_WARNING_FORMAT "{fg_yellow}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#define LOGGER_NOTICE_FORMAT "{fg_cyan}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#define LOGGER_INFO_FORMAT "{fg_blue}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#define LOGGER_DEBUG_FORMAT "{fg_green}" LOGGER_DEFAULT_FORMAT "{color_reset}"
#endif

namespace blet {

inline Logger::Logger(const char* name_, unsigned int queueMaxSize, unsigned int messageMaxSize) :
    name(name_),
    _isStarted(true),
    _currentMessageId(0),
    _droppedMessageNb(0),
    _levelFilter((1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7)),
    _pfile(stdout),
    _messageMaxSize(messageMaxSize),
    _queueMaxSize(queueMaxSize),
    _bufferMessages(new char[queueMaxSize * messageMaxSize]),
    _messages(new Message[queueMaxSize]),
    _messagesSwap(new Message[queueMaxSize]),
    _formats(new logger::Format[DEBUG + 1]),
    _perf(
#ifdef LOGGER_PERF_DEBUG
        new DebugPerf(name_)
#else
        NULL
#endif
    ) {
    std::cout.sync_with_stdio(false);
    for (unsigned int i = 0; i < _queueMaxSize; ++i) {
        _messages[i].message = _bufferMessages + i * _messageMaxSize;
        _messagesSwap[i].message = _bufferMessages + i * _messageMaxSize;
    }
    ::memset(&_queueMutex, 0, sizeof(_queueMutex));
    ::memset(&_logMutex, 0, sizeof(_logMutex));
    ::memset(&_condLog, 0, sizeof(_condLog));
    ::memset(&_condFlush, 0, sizeof(_condFlush));
#ifdef LOGGER_COLOR_LEVELS
    setTypeFormat(EMERGENCY, LOGGER_EMERGENCY_FORMAT);
    setTypeFormat(ALERT, LOGGER_ALERT_FORMAT);
    setTypeFormat(CRITICAL, LOGGER_CRITICAL_FORMAT);
    setTypeFormat(ERROR, LOGGER_ERROR_FORMAT);
    setTypeFormat(WARNING, LOGGER_WARNING_FORMAT);
    setTypeFormat(NOTICE, LOGGER_NOTICE_FORMAT);
    setTypeFormat(INFO, LOGGER_INFO_FORMAT);
    setTypeFormat(DEBUG, LOGGER_DEBUG_FORMAT);
#else
    // default format
    setAllFormat(LOGGER_DEFAULT_FORMAT);
#endif
    // init thread
    if (pthread_mutex_init(&_queueMutex, NULL)) {
        throw Exception("pthread_mutex_init: ", strerror(errno));
    }
    if (pthread_mutex_init(&_logMutex, NULL)) {
        throw Exception("pthread_mutex_init: ", strerror(errno));
    }
    if (pthread_mutex_init(&_droppedMutex, NULL)) {
        throw Exception("pthread_mutex_init: ", strerror(errno));
    }
    if (pthread_cond_init(&_condLog, NULL)) {
        throw Exception("pthread_cond_init: ", strerror(errno));
    }
    if (pthread_cond_init(&_condFlush, NULL)) {
        throw Exception("pthread_cond_init: ", strerror(errno));
    }
    if (sem_init(&_queueSemaphore, 0, 0)) {
        throw Exception("sem_init: ", strerror(errno));
    }
    if (sem_init(&_droppedMessageSemaphore, 0, 0)) {
        throw Exception("sem_init: ", strerror(errno));
    }
    if (pthread_create(&_threadLogId, NULL, &_threadLogger, this)) {
        throw Exception("pthread_create: ", strerror(errno));
    }
}

inline Logger::~Logger() {
    _isStarted = false;
    // unlock thread
    sem_post(&_queueSemaphore);
    pthread_join(_threadLogId, NULL);
    sem_close(&_queueSemaphore);
    sem_destroy(&_queueSemaphore);
    sem_close(&_droppedMessageSemaphore);
    sem_destroy(&_droppedMessageSemaphore);
    pthread_cond_destroy(&_condLog);
    pthread_cond_destroy(&_condFlush);
    pthread_mutex_destroy(&_queueMutex);
    pthread_mutex_destroy(&_logMutex);
    // delete messageQueue
    delete[] _bufferMessages;
    delete[] _messages;
    delete[] _messagesSwap;
    delete[] _formats;

#ifdef LOGGER_PERF_DEBUG
    delete _perf;
#endif
}

inline void Logger::flush() {
    int semValue = 1;
    pthread_mutex_lock(&_queueMutex);
    while (_isStarted && semValue > 0) {
        sem_getvalue(&_queueSemaphore, &semValue);
        if (semValue == 0) {
            sem_post(&_queueSemaphore);
        }
        pthread_cond_wait(&_condFlush, &_queueMutex);
    }
    pthread_mutex_unlock(&_queueMutex);
    fflush(_pfile);
}

inline void* Logger::_threadLogger(void* e) {
    Logger* loggin = static_cast<Logger*>(e);
    loggin->_threadLog();
    return NULL;
}

inline void Logger::printMessage(const Logger::Message& message) {
    static const char* levelToStr[] = {"EMERG", "ALERT", "CRIT", "ERROR", "WARN", "NOTICE", "INFO", "DEBUG"};
    // static char *buffer = new char[_messageMaxSize];

    const logger::Format* format = &_formats[message.level];

    // int index = 0;

    if (message.file) {
        std::list<logger::Format::Action>::const_iterator cit;
        for (cit = format->actions.begin(); cit != format->actions.end(); ++cit) {
            switch (cit->action) {
                case logger::Format::PRINT_ACTION:
                    fprintf(_pfile, cit->format.c_str(), 0);
                    break;
                case logger::Format::NAME_ACTION:
                    fprintf(_pfile, cit->format.c_str(), name.c_str());
                    break;
                case logger::Format::LEVEL_ACTION:
                    fprintf(_pfile, cit->format.c_str(), levelToStr[message.level]);
                    break;
                case logger::Format::PATH_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.file);
                    break;
                case logger::Format::FILE_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.filename);
                    break;
                case logger::Format::LINE_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.line);
                    break;
                case logger::Format::FUNC_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.function);
                    break;
                case logger::Format::PID_ACTION:
                    fprintf(_pfile, cit->format.c_str(), format->pid);
                    break;
                case logger::Format::TIME_ACTION:
                    char ftime[128];
                    struct tm t;
                    localtime_r(&(message.ts.tv_sec), &t);
                    strftime(ftime, 128, format->time.c_str(), &t);
                    fprintf(_pfile, cit->format.c_str(), ftime);
                    break;
                case logger::Format::DECIMAL_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.ts.tv_nsec / format->nsecDivisor);
                    break;
                case logger::Format::MESSAGE_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.message);
                    break;
                case logger::Format::TID_ACTION:
                    fprintf(_pfile, cit->format.c_str(), format->threadId);
                    break;
            }
        }
    }
    else {
        std::list<logger::Format::Action>::const_iterator cit;
        for (cit = format->actions.begin(); cit != format->actions.end(); ++cit) {
            switch (cit->action) {
                case logger::Format::PRINT_ACTION:
                    fprintf(_pfile, cit->format.c_str(), 0);
                    break;
                case logger::Format::NAME_ACTION:
                    fprintf(_pfile, cit->format.c_str(), name.c_str());
                    break;
                case logger::Format::LEVEL_ACTION:
                    fprintf(_pfile, cit->format.c_str(), levelToStr[message.level]);
                    break;
                case logger::Format::PID_ACTION:
                    fprintf(_pfile, cit->format.c_str(), format->pid);
                    break;
                case logger::Format::TIME_ACTION:
                    char ftime[128];
                    struct tm t;
                    localtime_r(&(message.ts.tv_sec), &t);
                    strftime(ftime, 128, format->time.c_str(), &t);
                    fprintf(_pfile, cit->format.c_str(), ftime);
                    break;
                case logger::Format::DECIMAL_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.ts.tv_nsec / format->nsecDivisor);
                    break;
                case logger::Format::MESSAGE_ACTION:
                    fprintf(_pfile, cit->format.c_str(), message.message);
                    break;
                case logger::Format::TID_ACTION:
                    fprintf(_pfile, cit->format.c_str(), format->threadId);
                    break;
                default:
                    break;
            }
        }
    }

    // fwrite(buffer, index, 1, _pfile);
}

inline void Logger::_threadLog() {
    unsigned int lastMessageId;
#ifndef LOGGER_ASYNC_WAIT_PRINT
    int lastDroppedNb = 0;
    timespec tsDropped;
    ::clock_gettime(CLOCK_REALTIME, &tsDropped);
#endif
    int semQueueValue = 1;
    while (_isStarted || semQueueValue > 0) {
        sem_wait(&_queueSemaphore);
        pthread_mutex_lock(&_queueMutex);
        if (_currentMessageId == 0) {
            sem_getvalue(&_queueSemaphore, &semQueueValue);
#ifdef LOGGER_ASYNC_WAIT_PRINT
            pthread_cond_signal(&_condLog);
#endif
            pthread_cond_broadcast(&_condFlush);
            pthread_mutex_unlock(&_queueMutex);
            continue;
        }
        // swap messages
        Message* tmp = _messages;
        _messages = _messagesSwap;
        _messagesSwap = tmp;
        // save last message id
        lastMessageId = _currentMessageId;
        // reset current message id
        _currentMessageId = 0;
#ifdef LOGGER_ASYNC_WAIT_PRINT
        pthread_cond_signal(&_condLog);
#else
        timespec currentTime;
        ::clock_gettime(CLOCK_REALTIME, &currentTime);
        if (currentTime.tv_sec > tsDropped.tv_sec) {
            tsDropped.tv_sec = currentTime.tv_sec;
            unsigned int messageDroppedCount = _droppedMessageNb - lastDroppedNb;
            if (messageDroppedCount > 0) {
#ifdef LOGGER_PERF_DEBUG
                _perf->messageCount += messageDroppedCount;
#endif
                _M_logFormat("Message dropped: %u", messageDroppedCount);
                _M_logInfos(WARNING, _LOGGER_FILE_INFOS);
                // move index
                ++_currentMessageId;
                lastDroppedNb += messageDroppedCount;
            }
        }

        // sem_getvalue(&_droppedMessageSemaphore, &semDroppedValue);
        // if (semDroppedValue - lastDroppedCount > 0) {
        //     #ifdef LOGGER_PERF_DEBUG
        //         _perf->messageCount += semDroppedValue - lastDroppedCount;
        //     #endif
        //     _M_logFormat("Message dropped: %i", semDroppedValue - lastDroppedCount);
        //     _M_logInfos(WARNING, _LOGGER_FILE_INFOS);
        //     // move index
        //     ++_currentMessageId;
        //     lastDroppedCount = semDroppedValue;
        // }
#endif
        pthread_mutex_unlock(&_queueMutex);

        // call print function
        for (unsigned int i = 0; i < lastMessageId; ++i) {
            printMessage(_messagesSwap[i]);
#ifdef LOGGER_PERF_DEBUG
            ++_perf->messagePrinted;
#endif
        }

        pthread_cond_broadcast(&_condFlush);
    }

#ifndef LOGGER_ASYNC_WAIT_PRINT
    unsigned int messageDroppedCount = _droppedMessageNb - lastDroppedNb;
    if (messageDroppedCount > 0) {
#ifdef LOGGER_PERF_DEBUG
        _perf->messageCount += messageDroppedCount;
#endif
        _M_logFormat("Message dropped: %u", messageDroppedCount);
        _M_logInfos(WARNING, _LOGGER_FILE_INFOS);
        printMessage(_messages[0]);
    }
#endif
}

inline void Logger::setTypeFormat(const eLevel& level, const char* format) {
    pthread_mutex_lock(&_queueMutex);
    _formats[level] = logger::Format(name, format);
    pthread_mutex_unlock(&_queueMutex);
}

inline void Logger::setAllFormat(const char* format) {
    pthread_mutex_lock(&_queueMutex);
    logger::Format fmt = logger::Format(name, format);
    for (int i = 0; i < DEBUG + 1; ++i) {
        _formats[i] = fmt;
    }
    pthread_mutex_unlock(&_queueMutex);
}

inline void Logger::setFILE(FILE* file) {
    _pfile = file;
}

inline void Logger::logSync(eLevel level, const char* format, ...) {
    ::pthread_mutex_lock(&_logMutex);
    // char message[LOGGER_MESSAGE_MAX_SIZE];
    Message msg;
    msg.message = reinterpret_cast<char*>(const_cast<char*>(format));

    ::clock_gettime(CLOCK_REALTIME, &msg.ts);

    // va_list vargs;
    // va_start(vargs, format);
    // ::vsnprintf(msg.message, _messageMaxSize, format, vargs);
    // va_end(vargs);

    // create a new message
    msg.level = level;
    msg.file = NULL;
    msg.filename = NULL;
    msg.line = 0;
    msg.function = NULL;

    printMessage(msg);
    ::pthread_mutex_unlock(&_logMutex);
}

inline void Logger::vlog(eLevel level, const char* format, va_list& vargs) {
    ::pthread_mutex_lock(&_logMutex);
    ::pthread_mutex_lock(&_queueMutex);
#ifdef LOGGER_ASYNC_WAIT_PRINT
    if (_currentMessageId >= _queueMaxSize - 1) {
        ::pthread_cond_wait(&_condLog, &_queueMutex);
    }
#endif

    if (_currentMessageId == 0) {
        ::sem_post(&_queueSemaphore);
    }

    ::clock_gettime(CLOCK_REALTIME, &_messages[_currentMessageId].ts);

    // copy formated message
    ::vsnprintf(_messages[_currentMessageId].message, _messageMaxSize, format, vargs);

    // create a new message
    _messages[_currentMessageId].level = level;
    _messages[_currentMessageId].file = NULL;
    _messages[_currentMessageId].filename = NULL;
    _messages[_currentMessageId].line = 0;
    _messages[_currentMessageId].function = NULL;

    // move index
    ++_currentMessageId;
#ifndef LOGGER_ASYNC_WAIT_PRINT
    if (_currentMessageId == _queueMaxSize) {
        _currentMessageId = 0;
    }
#endif

#ifdef LOGGER_PERF_DEBUG
    ++_perf->messageCount;
#endif
    ::pthread_mutex_unlock(&_queueMutex);
    ::pthread_mutex_unlock(&_logMutex);
}

inline void Logger::log(eLevel level, const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(level, format, vargs);
    va_end(vargs);
}

inline void Logger::emergency(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(EMERGENCY, format, vargs);
    va_end(vargs);
}

inline void Logger::alert(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(ALERT, format, vargs);
    va_end(vargs);
}

inline void Logger::critical(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(CRITICAL, format, vargs);
    va_end(vargs);
}

inline void Logger::error(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(ERROR, format, vargs);
    va_end(vargs);
}

inline void Logger::warning(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(WARNING, format, vargs);
    va_end(vargs);
}

inline void Logger::notice(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(NOTICE, format, vargs);
    va_end(vargs);
}

inline void Logger::info(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(INFO, format, vargs);
    va_end(vargs);
}

inline void Logger::debug(const char* format, ...) {
    va_list vargs;
    va_start(vargs, format);
    vlog(DEBUG, format, vargs);
    va_end(vargs);
}

inline void Logger::_M_logFormat(const char* format, ...) {
    // copy formated message
    va_list vargs;
    va_start(vargs, format);
    ::vsnprintf(_messages[_currentMessageId].message, _messageMaxSize, format, vargs);
    va_end(vargs);
}

inline void Logger::_M_logStream(const ::std::ostringstream& oss) {
    std::string str = oss.str();
    unsigned int cpySize = _messageMaxSize < str.size() ? _messageMaxSize : str.size() + 1;
    ::memcpy(_messages[_currentMessageId].message, str.c_str(), cpySize);
    if (cpySize == _messageMaxSize) {
        _messages[_currentMessageId].message[_messageMaxSize - 1] = '\0';
    }
}

inline void Logger::_M_logInfos(eLevel level, const char* file, const char* filename, int line, const char* function) {
#ifdef LOGGER_PERF_DEBUG
    ++_perf->messageCount;
#endif

    ::clock_gettime(CLOCK_REALTIME, &_messages[_currentMessageId].ts);

    // create a new message
    _messages[_currentMessageId].level = level;
    _messages[_currentMessageId].file = file;
    _messages[_currentMessageId].filename = filename;
    _messages[_currentMessageId].line = line;
    _messages[_currentMessageId].function = function;

    if (_currentMessageId == 0) {
        ::sem_post(&_queueSemaphore);
    }
}

} // namespace blet

// ------------------
// End src/logger.cpp
// ------------------

// ---------------------------
// Start src/logger/format.cpp
// ---------------------------
// #include "blet/logger/format.h" (already included)

#include <stdio.h>
#include <unistd.h>

#include <iostream>
#include <list>
#include <map>
#include <sstream>

#define LOGGER_OPEN_BRACE static_cast<char>(-41)
#define LOGGER_SEPARATOR static_cast<char>(-42)
#define LOGGER_CLOSE_BRACE static_cast<char>(-43)

#ifndef LOGGER_DEFAULT_TIME_FORMAT
#define LOGGER_DEFAULT_TIME_FORMAT "%x %X"
#endif

namespace blet {

namespace logger {

static inline void s_formatSerialize(std::string& str) {
    for (std::size_t i = 0; i < str.size(); ++i) {
        if (i > 0 && str[i - 1] == '\\') {
            if (str[i] == '\\') {
                str.erase(i - 1, 1);
            }
            else {
                --i;
                str.erase(i, 1);
            }
        }
        else if (str[i] == '{') {
            str[i] = LOGGER_OPEN_BRACE;
        }
        else if (str[i] == ':') {
            str[i] = LOGGER_SEPARATOR;
        }
        else if (str[i] == '}') {
            str[i] = LOGGER_CLOSE_BRACE;
        }
    }
}

static inline void s_formatDeserialize(std::string& str) {
    for (std::size_t i = 0; i < str.size(); ++i) {
        switch (str[i]) {
            case LOGGER_OPEN_BRACE:
                str[i] = '{';
                break;
            case LOGGER_SEPARATOR:
                str[i] = ':';
                break;
            case LOGGER_CLOSE_BRACE:
                str[i] = '}';
                break;
        }
    }
}

static inline void s_escapePercent(std::string& str) {
    for (std::size_t i = 0; i < str.size(); ++i) {
        if (str[i] == '%') {
            str.insert(i, "%");
            ++i;
        }
    }
}

static inline Format::eAction s_nameToEnumAction(const std::string& name) {
    static const std::pair<std::string, Format::eAction> nameToActionPairs[] = {
        std::pair<std::string, Format::eAction>("name", Format::NAME_ACTION),
        std::pair<std::string, Format::eAction>("level", Format::LEVEL_ACTION),
        std::pair<std::string, Format::eAction>("path", Format::PATH_ACTION),
        std::pair<std::string, Format::eAction>("file", Format::FILE_ACTION),
        std::pair<std::string, Format::eAction>("line", Format::LINE_ACTION),
        std::pair<std::string, Format::eAction>("func", Format::FUNC_ACTION),
        std::pair<std::string, Format::eAction>("pid", Format::PID_ACTION),
        std::pair<std::string, Format::eAction>("time", Format::TIME_ACTION),
        std::pair<std::string, Format::eAction>("decimal", Format::DECIMAL_ACTION),
        std::pair<std::string, Format::eAction>("message", Format::MESSAGE_ACTION),
        std::pair<std::string, Format::eAction>("tid", Format::TID_ACTION)};
    static const std::map<std::string, Format::eAction> nameToEnumAction(
        nameToActionPairs, nameToActionPairs + sizeof(nameToActionPairs) / sizeof(*nameToActionPairs));

    std::map<std::string, Format::eAction>::const_iterator cit = nameToEnumAction.find(name);
    if (cit == nameToEnumAction.end()) {
        return Format::PRINT_ACTION;
    }
    return cit->second;
}

static inline const char* s_idToDefaultFormat(const Format::eAction& id) {
    static const char* idToDefaultFormat[] = {
        "unknown",
        "%s", // name
        "%s", // level
        "%s", // path
        "%s", // file
        "%d", // line
        "%s", // func
        "%d", // pid
        "%s", // time
        "%d", // decimal
        "%s", // message
        "%X"  // threadid
    };
    return idToDefaultFormat[id];
}

static inline int s_getDecimalDivisor(const std::string& format) {
    int value = 1;
    std::size_t percentPos = format.find('%');
    if (percentPos != format.npos) {
        int log_10;
        std::stringstream ss("");
        ss << format.c_str() + percentPos + 1;
        ss >> log_10;
        if (log_10 < 0) {
            log_10 = -log_10;
        }
        log_10 = 9 - log_10;
        for (int i = 0; i < log_10; ++i) {
            value *= 10;
        }
    }
    return value;
}

static inline const char* s_nameToColorFormat(const std::string& name) {
    static const std::pair<std::string, const char*> nameToColorPairs[] = {
        std::pair<std::string, const char*>("color_reset", "\033[0m"),
        std::pair<std::string, const char*>("color_bold", "\033[1m"),
        std::pair<std::string, const char*>("color_dim", "\033[2m"),
        std::pair<std::string, const char*>("color_italic", "\033[3m"),
        std::pair<std::string, const char*>("color_underline", "\033[4m"),
        std::pair<std::string, const char*>("color_blink", "\033[5m"),
        std::pair<std::string, const char*>("color_rev", "\033[7m"),
        std::pair<std::string, const char*>("color_hide", "\033[8m"),
        std::pair<std::string, const char*>("fg_black", "\033[30m"),
        std::pair<std::string, const char*>("fg_red", "\033[31m"),
        std::pair<std::string, const char*>("fg_green", "\033[32m"),
        std::pair<std::string, const char*>("fg_yellow", "\033[33m"),
        std::pair<std::string, const char*>("fg_blue", "\033[34m"),
        std::pair<std::string, const char*>("fg_magenta", "\033[35m"),
        std::pair<std::string, const char*>("fg_cyan", "\033[36m"),
        std::pair<std::string, const char*>("fg_white", "\033[37m"),
        std::pair<std::string, const char*>("bg_black", "\033[40m"),
        std::pair<std::string, const char*>("bg_red", "\033[41m"),
        std::pair<std::string, const char*>("bg_green", "\033[42m"),
        std::pair<std::string, const char*>("bg_yellow", "\033[43m"),
        std::pair<std::string, const char*>("bg_blue", "\033[44m"),
        std::pair<std::string, const char*>("bg_magenta", "\033[45m"),
        std::pair<std::string, const char*>("bg_cyan", "\033[46m"),
        std::pair<std::string, const char*>("bg_white", "\033[47m")};
    static const std::map<std::string, const char*> nameToColorFormat(
        nameToColorPairs, nameToColorPairs + sizeof(nameToColorPairs) / sizeof(*nameToColorPairs));

    const char* ret = "";
    std::map<std::string, const char*>::const_iterator cit = nameToColorFormat.find(name);
    if (cit != nameToColorFormat.end()) {
        ret = cit->second;
    }
    return ret;
}

inline Format::Format() :
    time(""),
    pid(0),
    threadId(0),
    nsecDivisor(1) {}

inline Format::Format(const std::string& loggerName, const char* format) :
    time(""),
    pid(0),
    threadId(0),
    nsecDivisor(1) {
    std::string sFormat(format);
    // transform "{:}" non escape characters
    s_formatSerialize(sFormat);
    // search first occurence of '{'
    std::size_t lastIndexStart = 0;
    std::size_t indexStart = sFormat.find(LOGGER_OPEN_BRACE);
    std::size_t indexEnd;
    std::size_t indexFormat;
    while (indexStart != std::string::npos) {
        // search first occurrence of '}' after indexStart
        indexEnd = sFormat.find(LOGGER_CLOSE_BRACE, indexStart);
        if (indexEnd == std::string::npos) {
            break;
        }
        // substr the part before key
        if (lastIndexStart - indexStart > 0) {
            std::string beforeKey = sFormat.substr(lastIndexStart, indexStart - lastIndexStart);
            s_formatDeserialize(beforeKey);
            s_escapePercent(beforeKey);
            actions.push_back(Action(PRINT_ACTION, beforeKey));
        }
        lastIndexStart = indexEnd + 1;
        // search first occurrence of ':' after indexStart
        indexFormat = sFormat.find(LOGGER_SEPARATOR, indexStart);
        // if ':' not found or ':' is not between '{' and '}'
        if (indexFormat == std::string::npos || indexFormat > indexEnd) {
            // get name of key {[...]}
            std::string key = sFormat.substr(indexStart + 1, indexEnd - indexStart - 1);
            // get the id of key
            eAction actionId = s_nameToEnumAction(key);
            if (actionId != PRINT_ACTION) {
                switch (actionId) {
                    case PID_ACTION:
                        pid = ::getpid();
                        break;
                    case TID_ACTION:
                        threadId = ::pthread_self();
                        break;
                    case TIME_ACTION:
                        time = LOGGER_DEFAULT_TIME_FORMAT;
                        break;
                    default:
                        break;
                }
                actions.push_back(Action(actionId, s_idToDefaultFormat(actionId)));
            }
            else {
                // check if color
                const char* color = s_nameToColorFormat(key);
                actions.push_back(Action(PRINT_ACTION, color));
            }
            indexStart = sFormat.find(LOGGER_OPEN_BRACE, indexStart + 1);
            // find other key
            continue;
        }
        else {
            // get name of key {[...]:...}
            std::string key = sFormat.substr(indexStart + 1, indexFormat - indexStart - 1);
            // get format of key {...:[...]}
            std::string formatKey = sFormat.substr(indexFormat + 1, indexEnd - indexFormat - 1);
            // replace no print character by real
            s_formatDeserialize(formatKey);
            // get the id of key
            eAction actionId = s_nameToEnumAction(key);
            if (actionId != PRINT_ACTION) {
                switch (actionId) {
                    case PID_ACTION:
                        pid = ::getpid();
                        break;
                    case TID_ACTION:
                        threadId = ::pthread_self();
                        break;
                    case TIME_ACTION:
                        time = formatKey;
                        formatKey = "%s";
                        break;
                    case DECIMAL_ACTION:
                        nsecDivisor = s_getDecimalDivisor(formatKey);
                        break;
                    default:
                        break;
                }
                actions.push_back(Action(actionId, formatKey));
            }
            else {
                s_escapePercent(formatKey);
                actions.push_back(Action(PRINT_ACTION, formatKey));
            }
            // parse other key
            indexStart = sFormat.find(LOGGER_OPEN_BRACE, indexStart + 1);
            continue;
        }
    }
    // get last characters in format
    if (lastIndexStart - sFormat.size() > 0) {
        std::string lastFormat = sFormat.substr(lastIndexStart, sFormat.size() - lastIndexStart);
        s_formatDeserialize(lastFormat);
        s_escapePercent(lastFormat);
        actions.push_back(Action(PRINT_ACTION, lastFormat));
    }
    // search if message is exist
    std::list<Action>::iterator it;
    for (it = actions.begin(); it != actions.end(); ++it) {
        if (it->action == MESSAGE_ACTION) {
            break;
        }
    }
    // add message action if not exist
    if (it == actions.end()) {
        actions.push_back(Action(MESSAGE_ACTION, s_idToDefaultFormat(MESSAGE_ACTION)));
    }
    // add \n on last action
    actions.push_back(Action(PRINT_ACTION, "\n"));
    // compress actions
    it = actions.begin();
    while (it != actions.end()) {
        // replace action by string
        if (it->action == NAME_ACTION || it->action == PID_ACTION || it->action == TID_ACTION) {
            char buffer[128];
            switch (it->action) {
                case NAME_ACTION:
                    ::snprintf(buffer, sizeof(buffer), it->format.c_str(), loggerName.c_str());
                    break;
                case PID_ACTION:
                    ::snprintf(buffer, sizeof(buffer), it->format.c_str(), pid);
                    break;
                case TID_ACTION:
                    ::snprintf(buffer, sizeof(buffer), it->format.c_str(), threadId);
                    break;
                default:
                    break;
            }
            std::string str(buffer);
            s_escapePercent(str);
            it->action = PRINT_ACTION;
            it->format = str;
        }
        std::list<Action>::iterator prev = it;
        ++it;
        if (prev->action == PRINT_ACTION) {
            // concat with next if exist
            if (it != actions.end()) {
                it->format = prev->format + it->format;
                it = actions.erase(prev);
            }
            // concat with prev
            else {
                --it;
                --it;
                std::list<Action>::iterator prev = it;
                ++it;
                prev->format = prev->format + it->format;
                it = actions.erase(it);
            }
        }
    }
}

inline Format::~Format() {}

} // namespace logger

} // namespace blet

#undef LOGGER_OPEN_BRACE
#undef LOGGER_SEPARATOR
#undef LOGGER_CLOSE_BRACE

// -------------------------
// End src/logger/format.cpp
// -------------------------

#endif // #ifndef _AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_LOGGER_H_